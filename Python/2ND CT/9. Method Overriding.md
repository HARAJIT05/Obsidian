# 9. Evaluate the method overriding with Example.

**Method overriding** is an object-oriented programming concept that allows a subclass (or child class) to provide a specific implementation of a method that is already provided by one of its superclasses (or parent classes).

When a method in a subclass has the same name, same parameters or signature, and same return type as a method in its superclass, then the method in the subclass is said to override the method in the superclass.

## Evaluation:

- **Polymorphism:** Overriding is essential for polymorphism. It allows you to call a method on an object of a parent class type, and the implementation of the child class's method is executed if the object is an instance of the child class. This allows for more generic and dynamic code.
- **Customization:** It allows subclasses to customize or completely change the behavior of a method defined in the superclass to suit their specific needs, without modifying the superclass itself.
- **Code Reusability:** It promotes code reuse. The parent class can define a generic behavior, and child classes can reuse that logic (by calling `super()`) and add their own specific behavior on top of it.

## Example:

Let's consider a `Shape` class with a method `area()`. A generic shape doesn't have a specific area calculation, so it might return 0. Subclasses like `Square` and `Circle` can then override this method to provide the correct formula.

```python
# Parent class
class Shape:
    def __init__(self, name):
        self.name = name

    def area(self):
        """A generic shape has no defined area."""
        print(f"Calculating area for a generic {self.name}...")
        return 0

# Child class 1
class Square(Shape):
    def __init__(self, side_length):
        super().__init__("Square")
        self.side_length = side_length

    def area(self):
        """Overrides the parent's area method for a square."""
        print(f"Calculating area for a {self.name}...")
        return self.side_length ** 2

# Child class 2
class Circle(Shape):
    def __init__(self, radius):
        super().__init__("Circle")
        self.radius = radius

    def area(self):
        """Overrides the parent's area method for a circle."""
        print(f"Calculating area for a {self.name}...")
        return 3.14159 * (self.radius ** 2)

# --- Demonstration ---
generic_shape = Shape("Shape")
my_square = Square(5)
my_circle = Circle(3)

shapes = [generic_shape, my_square, my_circle]

# Polymorphism in action
for shape in shapes:
    # The correct .area() method is called for each object
    print(f"The area is: {shape.area()}\n")

```

### Output:
```
Calculating area for a generic Shape...
The area is: 0

Calculating area for a Square...
The area is: 25

Calculating area for a Circle...
The area is: 28.27431
```
In this example, when `shape.area()` is called in the loop, Python dynamically determines which version of the `area` method to execute based on the object's actual class (`Shape`, `Square`, or `Circle`). This is the power of method overriding.
