# 10. Evaluate the benefit of using inheritance in python for object oriented programming.

**Inheritance** is one of the core principles of Object-Oriented Programming (OOP). It is the mechanism by which one class (the "child" or "subclass") can acquire the properties (attributes) and behaviors (methods) of another class (the "parent" or "superclass").

## Key Benefits of Inheritance:

1.  **Code Reusability:** This is the most significant benefit. The parent class defines common attributes and methods that can be shared across multiple child classes. Child classes can then inherit this functionality without having to rewrite the code. This follows the DRY (Don't Repeat Yourself) principle.

2.  **Logical Hierarchy (Is-A Relationship):** Inheritance allows you to create a logical "Is-A" relationship between classes. For example, a `Car` **is a** `Vehicle`, a `Dog` **is an** `Animal`. This creates a clear and organized class structure that models real-world relationships, making the code easier to understand and maintain.

3.  **Polymorphism:** Inheritance is a prerequisite for polymorphism. It allows objects of different classes (that share a common parent) to be treated as objects of the parent class. This enables you to write more generic and flexible code that can work with objects of multiple types. (See also [[9. Method Overriding]]).

4.  **Extensibility and Customization:** A child class can not only inherit functionality but can also add its own new methods and attributes. It can also customize inherited methods through method overriding to provide specific behavior while still reusing the parts of the parent's logic it needs.

## Example:

Let's model different types of employees in a company. They all share common properties like `name` and `employee_id`, but their salary calculation might differ.

```python
# Parent class with common attributes and methods
class Employee:
    def __init__(self, name, employee_id):
        self.name = name
        self.employee_id = employee_id

    def display_info(self):
        print(f"ID: {self.employee_id}, Name: {self.name}")

# Child class 1: SalariedEmployee
class SalariedEmployee(Employee):
    def __init__(self, name, employee_id, monthly_salary):
        # Reuse the parent's __init__ method
        super().__init__(name, employee_id)
        self.monthly_salary = monthly_salary

    def calculate_pay(self):
        return self.monthly_salary

# Child class 2: HourlyEmployee
class HourlyEmployee(Employee):
    def __init__(self, name, employee_id, hours_worked, hourly_rate):
        # Reuse the parent's __init__ method
        super().__init__(name, employee_id)
        self.hours_worked = hours_worked
        self.hourly_rate = hourly_rate

    def calculate_pay(self):
        return self.hours_worked * self.hourly_rate

# --- Demonstration ---
salaried_emp = SalariedEmployee("Alice", "E123", 5000)
hourly_emp = HourlyEmployee("Bob", "E456", 40, 25)

# Both objects can use the display_info() method from the parent class
salaried_emp.display_info()
print(f"Monthly Pay: ${salaried_emp.calculate_pay()}\n")

hourly_emp.display_info()
print(f"Weekly Pay: ${hourly_emp.calculate_pay()}")
```
In this example, `SalariedEmployee` and `HourlyEmployee` both inherit from `Employee`, reusing the `__init__` and `display_info` logic. They then extend the functionality with their own specific `calculate_pay` methods. This avoids code duplication and creates a clean, logical structure.
